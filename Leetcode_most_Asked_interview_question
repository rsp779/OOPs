//Surrounded region => water flows from all sides so we have to find where the water can be stored(similar)

class Solution {
public:
    bool not_possible(int row,int col,int rowsize,int colsize,vector<vector<char>>&board)
    {
        if(row<0 || col<0 || row>=rowsize || col>=colsize || board[row][col]!='O' )
            return true;
        
         return false;
    }
    void markup(int row,int col,int rowsize,int colsize,vector<vector<char>>&board,vector<int>&dir)
    {
        if(not_possible(row,col,rowsize,colsize,board))return;
        
        board[row][col]='Y';
        
        for(int i=0;i<4;i++){
            int next_x=row+dir[i];
            int next_y=col+dir[i+1];
            
            markup(next_x,next_y,rowsize,colsize,board,dir);
        }
    }
    void solve(vector<vector<char>>& board) {
        int rowsize=board.size(),colsize=board[0].size();
        
        vector<int>dir={1,0,-1,0,1};
        
        for(int row=0;row<rowsize;row++){
           
            if(board[row][0]=='O')
            markup(row,0,rowsize,colsize,board,dir);
            
            if(board[row][colsize-1]=='O')
            markup(row,colsize-1,rowsize,colsize,board,dir);
            
        }
        
        for(int col=0;col<colsize;col++){
            
            if(board[0][col]=='O')
                markup(0,col,rowsize,colsize,board,dir);
            
            if(board[rowsize-1][col]=='O')
                markup(rowsize-1,col,rowsize,colsize,board,dir);
            
        }
        
        for(int row=0;row<rowsize;row++){
            for(int col=0;col<colsize;col++){
               
                if(board[row][col]=='O')
                    board[row][col]='X';
                
                if(board[row][col]=='Y')
                    board[row][col]='O';
            }
        }
    }
};


//Word Break 2 . Given a string s and a dictionary of strings wordDict, 
add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.

class Solution {
public:
    void solve(string &s,string &str,vector<string>&ans,int index,
               unordered_map<string,int>&mp){
        
        if(index==s.size()){
            str.pop_back();   //this about the last space
            ans.push_back(str);
            str.push_back(' ');
            return ;
        }
        
        for(int i=index;i<s.size();i++){
            
            string cur=s.substr(index,i-index+1);
            if(mp.find(cur)!=mp.end()){
                str.append(cur);
                str.push_back(' ');
                solve(s,str,ans,i+1,mp);
                str.pop_back();
               
               str=str.substr(0,str.size()-(i-index+1)); // most important line for this question
               
            }
        }
    }
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        vector<string>ans;
        string str="";
        unordered_map<string,int>mp;
        
        for(int i=0;i<wordDict.size();i++)
            mp[wordDict[i]]++;
        
        solve(s,str,ans,0,mp);
        
        return ans;
    }
};

//Seive of erathonese 
// without if statement TC is O(nlogn)
// with if statement TC is O(nlog(logn))

class Solution {
public:
    int countPrimes(int n) {
        vector<int>prime(n+1,true);
        int sqqrt=sqrt(n);
        
        for(long long int i=2;i<=sqqrt;i++){
            
            if(prime[i]==true){
            for(long long int j=2;i*j<=n;j++)
            {
                prime[j*i]=false;
            } 
            }
        }
        int count=0;
        
        for(int i=2;i<n;i++){
            
            if(prime[i]==true)
                count++;
            
        }
        return count;
    }
};

//Reverse an array by k position
//=> reverse (0 to that position) then reverse(that position to end ) then reverse the entire vector
class Solution {
public:
    void reverse(vector<int>&nums,int start,int end){
        while(start<end){
            swap(nums[start++],nums[end--]);
        }
    }
    void rotate(vector<int>& nums, int k) {
       
        k=(k+nums.size())%nums.size();
        reverse(nums,0,nums.size()-k-1);
        reverse(nums,nums.size()-k,nums.size()-1);
        reverse(nums,0,nums.size()-1);
    }
};


// Basic Calculator 2 
I stored the previous sign and decided what to do on my current number 

 int calculate(string s) {
        
        
        char sign='+';
        int val=0;
        stack<int>st;
        for(int i=0;i<s.size();i++){
            
            if(s[i]==' ')continue ;
            
            if(s[i]>='0' && s[i]<='9'){
                
                while(i<s.size() && (s[i]>='0' && s[i]<='9')){
                    val=val*10 + (s[i]-'0');
                    i++;
                }
                
                if(sign=='+' || sign=='-'){
                    st.push((sign=='+')?val : -val);
                }
                
                else if (sign=='*'){
                    int top_val=st.top();
                    st.pop();
                    st.push(top_val*val);
                }
                else {
                     int top_val=st.top();
                    st.pop();
                    st.push(top_val/val);
                }
                val=0;
                i--;
            }
            else sign=s[i];
        }
        int ans=0;
        while(!st.empty()){
            ans+=st.top();
            st.pop();
        }
        return ans;
}

If in a 2d matrix arrays are sorted in rowise and column wise 
1. last element of previous row < first element of current row => O(logn)
2. if not the above case then O(n+m)
        

// Given an integer n, return the least number of perfect square numbers that sum to n.

    int numSquares(int n) {
        
        
        
       
        vector<int>nums;
        int square_root=sqrt(n);
        if(square_root * square_root ==  n)return 1;
        
        for(int i=1;i<=square_root;i++){
            nums.push_back(i*i);
        }
        int m=nums.size();  //minimum number of coins to make the sum
        
        vector<vector<int>>dp(m+1,vector<int>(n+1,INT_MAX-1));
        dp[0][0]=0;
        for(int i=1;i<=m;i++){
           
            for(int j=0;j<=n;j++){
                
                dp[i][j]=dp[i-1][j];
                
            
                
                 if(j>=nums[i-1]){
                    dp[i][j]=min(dp[i][j],1+dp[i][j-nums[i-1]]);
            
                }
             
            }
        }
        return dp[m][n];        
}


// Wiggle Sort 2 a<b>c<d>e<f

 void wiggleSort(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        int n=nums.size();
        int maxval=nums[n-1]+1;
        
        int start=(n-1)/2,end=n-1;
       
        for(int i=0;i<n;i++){
            
            if(i%2==0){
                nums[i]=(nums[start--]%maxval)*maxval+nums[i];
            }
            else {
                nums[i]=(nums[end--]%maxval)*maxval + nums[i];
            }
            
        }
        for(int i=0;i<n;i++){
            nums[i]=nums[i]/maxval;
        }
    }
       

