//Surrounded region => water flows from all sides so we have to find where the water can be stored(similar)

class Solution {
public:
    bool not_possible(int row,int col,int rowsize,int colsize,vector<vector<char>>&board)
    {
        if(row<0 || col<0 || row>=rowsize || col>=colsize || board[row][col]!='O' )
            return true;
        
         return false;
    }
    void markup(int row,int col,int rowsize,int colsize,vector<vector<char>>&board,vector<int>&dir)
    {
        if(not_possible(row,col,rowsize,colsize,board))return;
        
        board[row][col]='Y';
        
        for(int i=0;i<4;i++){
            int next_x=row+dir[i];
            int next_y=col+dir[i+1];
            
            markup(next_x,next_y,rowsize,colsize,board,dir);
        }
    }
    void solve(vector<vector<char>>& board) {
        int rowsize=board.size(),colsize=board[0].size();
        
        vector<int>dir={1,0,-1,0,1};
        
        for(int row=0;row<rowsize;row++){
           
            if(board[row][0]=='O')
            markup(row,0,rowsize,colsize,board,dir);
            
            if(board[row][colsize-1]=='O')
            markup(row,colsize-1,rowsize,colsize,board,dir);
            
        }
        
        for(int col=0;col<colsize;col++){
            
            if(board[0][col]=='O')
                markup(0,col,rowsize,colsize,board,dir);
            
            if(board[rowsize-1][col]=='O')
                markup(rowsize-1,col,rowsize,colsize,board,dir);
            
        }
        
        for(int row=0;row<rowsize;row++){
            for(int col=0;col<colsize;col++){
               
                if(board[row][col]=='O')
                    board[row][col]='X';
                
                if(board[row][col]=='Y')
                    board[row][col]='O';
            }
        }
    }
};


//Word Break 2 . Given a string s and a dictionary of strings wordDict, 
add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.

class Solution {
public:
    void solve(string &s,string &str,vector<string>&ans,int index,
               unordered_map<string,int>&mp){
        
        if(index==s.size()){
            str.pop_back();   //this about the last space
            ans.push_back(str);
            str.push_back(' ');
            return ;
        }
        
        for(int i=index;i<s.size();i++){
            
            string cur=s.substr(index,i-index+1);
            if(mp.find(cur)!=mp.end()){
                str.append(cur);
                str.push_back(' ');
                solve(s,str,ans,i+1,mp);
                str.pop_back();
               
               str=str.substr(0,str.size()-(i-index+1)); // most important line for this question
               
            }
        }
    }
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        vector<string>ans;
        string str="";
        unordered_map<string,int>mp;
        
        for(int i=0;i<wordDict.size();i++)
            mp[wordDict[i]]++;
        
        solve(s,str,ans,0,mp);
        
        return ans;
    }
};

//Seive of erathonese 
// without if statement TC is O(nlogn)
// with if statement TC is O(nlog(logn))

class Solution {
public:
    int countPrimes(int n) {
        vector<int>prime(n+1,true);
        int sqqrt=sqrt(n);
        
        for(long long int i=2;i<=sqqrt;i++){
            
            if(prime[i]==true){
            for(long long int j=2;i*j<=n;j++)
            {
                prime[j*i]=false;
            } 
            }
        }
        int count=0;
        
        for(int i=2;i<n;i++){
            
            if(prime[i]==true)
                count++;
            
        }
        return count;
    }
};

//Reverse an array by k position
//=> reverse (0 to that position) then reverse(that position to end ) then reverse the entire vector
class Solution {
public:
    void reverse(vector<int>&nums,int start,int end){
        while(start<end){
            swap(nums[start++],nums[end--]);
        }
    }
    void rotate(vector<int>& nums, int k) {
       
        k=(k+nums.size())%nums.size();
        reverse(nums,0,nums.size()-k-1);
        reverse(nums,nums.size()-k,nums.size()-1);
        reverse(nums,0,nums.size()-1);
    }
};
