#include <bits/stdc++.h>
using namespace std;

//submatrix max sum size of B

int solve(vector<vector<int>>v<int B)
{
    int n=v.size();
    int m=v[0].size();
    
    vector<vector<int>>dp(n+1,vector<int>(m+1,0));
    
    for(int i=1;i<=n;i++)
    {
        for(int j=1;j<=m;j++)
        {
            dp[i][j]=v[i-1][j-1]+dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];
        }
    }
    
    int ans=INT_MIN;
    
    for(int i=B;i<=n;i++)
    {
        for(int j=B;j<=m;j++)
        {
            ans=max(ans,dp[i][j]-dp[i-B][j]-dp[i][j-B]+dp[i-B][j-B]);
        }
    }
}

//find the first missing positive integer 
int solve(vector<int>v)
{
    int n=v.size();
    
    for(int i=0;i<n;i++)
    {
        if(A[i]>0 && A[i]<n)
        {
            int pos=A[i]-1;
            
            if(A[i]!A[pos])
            {
                swap(A[i],A[pos]);
                i--;
            }
        }
    }
    for(int i=0;i<n;i++)
    {
        if(A[i]!=(i+1))
        return i+1;
    }
    return n+1;
}

//Set Matrix Zero 
void Solution::setZeroes(vector<vector<int> > &A) {
    int n=A.size();
    int m=A[0].size();
    
    bool row=false;
    bool col=false;
    
    for(int i=0;i<n;i++)
    {
        if(A[i][0]==0)
        row=true;
    }
    
    for(int j=0;j<m;j++)
    {
        if(A[0][j]==0)
        col=true;
    }
    
    for(int i=1;i<n;i++)
    {
        for(int j=1;j<m;j++)
        {
            if(A[i][j]==0)
            {
                A[0][j]=0;
                A[i][0]=0;
            }
        }
    }
    
    for(int i=1;i<n;i++)
    {
        for(int j=1;j<m;j++)
        {
            if(A[i][j]==1 && (A[i][0]==0 || A[0][j]==0))
            A[i][j]=0;
        }
    }
    if(row)
    {
        for(int i=0;i<n;i++)
        A[i][0]=0;
    }
    if(col)
    {
        for(int j=0;j<m;j++)
        A[0][j]=0;
    }
}


//Given an array A of integers, find the maximum of j - i subjected to the constraint of A[i] <= A[j].
int Solution::maximumGap(const vector<int> &A) {

    int n=A.size();
    vector<int>rig(n,0);

    rig[n-1]=A[n-1];

    for(int i=n-2;i>=0;i--)
    rig[i]=max(rig[i+1],A[i]);

    int i=0,j=0;
    int ans=0;
    while(i<n && j<n)
    {
       if(rig[j]>=A[i])
       {
       ans=max(ans,j-i);
       j++;
       }
       else i++;
    }
    return ans;
}

//Hotel Bookings Possible 
bool Solution::hotel(vector<int> &arrive, vector<int> &depart, int K) {
        sort(arrive.begin(),arrive.end());
        sort(depart.begin(),depart.end());
        
        int i=0,j=0;
        int n=arrive.size();
        int maxroomreq=0;
        while(i<n)
        {
            if(arrive[i]<depart[j])
            {
                i++;
                maxroomreq=max(maxroomreq,i-j);
            }
            else j++;
        }
       
        if(maxroomreq>K)
        return false;
        
        return true;
}

//Find Permutation 
vector<int> Solution::findPerm(const string A, int B) {
    
    int n=A.size();
    vector<int>ans(n+1,0);
    int j=B;
    int i=1;
    
    int k=0;
    
    while(k<n)
    {
        if(A[k]=='D')
        ans[k]=j--;
        else ans[k]=i++;
        
        k++;
    }
    ans[k]=i;
    return ans;
}

//largest number possible 
static bool sortbysec(string a,string b)
{
    string c=a;
    string d=b;
    string e=a;
    string f=b;
    string st1=c+d;
    string st2=d+c;
    
    //cout<<st2<<" "<<st1<<endl;
    if(st2.compare(st1)>0)
    return false;
    
    return true;
}
string Solution::largestNumber(const vector<int> &A) {
    
    vector<string>s;
    int n=A.size();
    for(int i=0;i<n;i++)
    s.push_back(to_string(A[i]));
    string ans="";
   sort(s.begin(),s.end(),sortbysec);
   for(int i=0;i<n;i++)
  ans=ans.append(s[i]);
  
  int x=ans.length();
  int i=0;
  while(ans[i]=='0' && (i<x-1))
  {
      i++;
  }
   ans=ans.substr(i,x-i);
   return ans;
    
    
}

//rotate Matrix 
void Solution::rotate(vector<vector<int> > &A) {
    int n=A.size()-1;
    int x=0,y=n;
    int temp=0;
    while(temp<y)
    {
        for(int j=x;j<y;j++)
        {
            int temp=A[x][j];
            A[x][j]=A[n-j][x];
            A[n-j][x]=A[n-x][n-j];
            A[n-x][n-j]=A[j][n-x];
            A[j][n-x]=temp;
        }
        x++;
        temp++;
        y--;
    }
}
//Next permutation 
vector<int> Solution::nextPermutation(vector<int> &A) {
    
    int index=-1;
    int n=A.size();
    if(n==1)
    return A;
    for(int i=n-1;i>0;i--)
    {
        if(A[i]>A[i-1])
        {
            index=i-1;
            break;
        }
    }
    if(index==-1)
    {
    sort(A.begin(),A.end());
    return A;
    }
    int sec=-1;
    int mi=INT_MAX;
    for(int i=index+1;i<n;i++)
    {
        if(A[i]>A[index]  && mi>A[i] )
        {
            sec=i;
            mi=A[i];
        }
    }
    swap(A[sec],A[index]);
  
    reverse(A.begin()+index+1,A.end());
    return A;
}

int main() {
	// your code goes here
	return 0;
}
