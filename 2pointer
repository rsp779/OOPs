#include <iostream>
using namespace std;

//pair with a given difference
int Solution::solve(vector<int> &A, int B) {
   
    sort(A.begin(),A.end());
  
  
    int i=0,j=0;
    while(j<A.size() && i<A.size())
    {
        if( i!=j && (A[j]-A[i])==B )
        return 1;
        
       if(A[j]-A[i]<B)
       {
           j++;
       }
       else {
           i++;
       }
       
    }
    return 0;
}

//3 sum nearest 
int Solution::threeSumClosest(vector<int> &A, int B) {
    int n=A.size();
    long long int ans=0;
    long long int nearness=INT_MAX;
    sort(A.begin(),A.end());
    for(int k=0;k<n;k++)
    {
        int i=k+1;
        int j=n-1;
        while(i<j)
        {
            long long int sum=A[k]+A[i]+A[j];
            
            if(abs(B-sum)<nearness)
            {
                ans=sum;
                nearness=abs(B-sum);
            }
            if(sum>B)
            j--;
            else i++;
        }
    }
    return ans;
    
}

//Counting Triangles
int Solution::nTriang(vector<int> &A) {
    sort(A.begin(),A.end());
    int mod=1e9+7;
    int low=0;
    while(A[low]==0)
    low++;
    long long int ans=0;
    for(int i=A.size()-1;i>=low+2;i--)
    {
        int l=low;
        int h=i-1;
        while(l<h)
        {
            int a=A[l];
            int b=A[h];
            int c=A[i];
            
            if(a+b>c)
            {
                ans+=(h-l);
                h--;
            }
            else {
                l++;
            }
            
        }
    }
    return ans%mod;
}
//Maximum Ones after modification 

int Solution::solve(vector<int> &A, int B)
{
    int i=0,j=0;
    int n=A.size();
    int ans=0;
    while(j<n)
    {
        while(j<n && B>0)
        {
            if(A[j]==0)
            B--;
            
             j++;
             
            ans=max(ans,j-i);
        }
        while(i<=j && B<0)
        {
            if(A[i]==0)
            B++;
            i++;
        }
    }
    return ans;
}

//Maximum number of 1 after chaging B number of zero continuous 
int Solution::solve(vector<int> &A, int B) {
   int i=0,j=0;
    int n=A.size();
    int ans=0;
    while(j<n)
    {
        while(j<n && B>=0)
        {
            if(A[j]==0)
            B--;
            
              j++;
              if(B>=0)
            ans=max(ans,j-i);
           
           // cout<<ans<<endl;
        }
        while(i<=j && B!=0)
        {
            if(A[i]==0)
            B++;
            i++;
        }
    }
    return ans;
}

// subarray with sum B 
int Solution::solve(vector<int> &A, int B)
{
    int sum=0;
    
    int i=0,j=0;
    int n=A.size();
    int ans=0;
    
    while(j<n)
    {
        if(sum+A[j]<B)
        {
            sum+=A[j];
            ans+=(j-i+1);
            j++;
        }
        else {
            sum-=A[i];
            i++;
        }
    }
    
    return ans;
}

//Exact B integers 
int cal(vector<int>v,int B)
{
    unordered_map<int,int>mp;
    
    int j=0,i=0,n=v.size();
    int count=0;
    int ans=0;
    
    while(j<n)
    {
        mp[v[j]]++;
        
        if(mp[v[j]]==1)
        count++;
        
        if(count<=B)
        {
            ans+=(j-i+1);
            j++;
        }
        else {
            mp[v[i]]--;
            if(mp[v[i]]==0)
            count-=1;
            i++;
        }
    }
    return ans;
    
    
}






int solve(vector<int>A,int B)
{
    return cal(A,B)-cal(A,B-1);
}


int main() {
	// your code goes here
	return 0;
}
